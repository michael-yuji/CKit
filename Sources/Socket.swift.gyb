%{
    from Common import *
    from Helper import *

    uni_sockopts = [
        ('sendBufferSize', 'SNDBUF', 'Int'),
        ('recvBufferSize', 'RCVBUF', 'Int'),
        ('sendLowAt', 'SNDLOWAT', 'Int'),
        ('recvLowAt', 'RCVLOWAT', 'Int'),
        ('recvTimeout','RCVTIMEO','timeval'),
        ('sendTimeout', 'SNDTIMEO', 'timeval'),
        ('timestampEnabled', 'TIMESTAMP', 'Bool'),
        ('socktype', 'type', 'Int32'),
        ('geterror', 'ERROR', 'Int32',),
        ('listenStatus', 'acceptconn', 'Bool'),
        ('broadcast', 'broadcast', 'Bool'),
        ('debug', 'debug', 'Bool'),
        ('dontRoute', 'dontroute', 'Bool'),
        ('reuseaddr', 'reuseaddr', 'Bool'),
        ('reuseport', 'reuseport', 'Bool'),
        ('keepalive', 'keepalive', 'Bool'),
        ('linger', 'linger', 'Int'),
        ('oobInline', 'oobinline', 'Bool')
    ]

    immutable = [
        'geterror', 'listenStatus', 'acceptconn', '`protocol`',
        'noSigpipe', 'type', 'dataAvailable', 'bytesPending2Write'
    ]

    bsd_opts = [
        ('noSigpipe', 'NOSIGPIPE', 'Bool'),
    ]

    fbsd_opts = [
        ('acceptedFilter', 'acceptFilter', 'accept_filter'),
        ('`protocol`', 'protocol', 'Int32'),
    ]

    linux_opts = [
    #    ('attachFilter', 'attach_bpf', 'sock_fprog'),
    #    ('bindDevice', 'bindtodevice', 'Int8'),
        ('`protocol`', 'protocol', 'Int32')
    ]

    flags = {
        'Send' : [
            ('outOfBond', 'OOB'), ('dontRoute', 'DONTROUTE'),
            ('eor', 'EOR'), ('dontWait', 'DONTWAIT')
        ],
        'Recv' : [
            ('outOfBond', 'OOB'), ('peek', 'PEEK'), ('waitall', 'WAITALL'),
            ('dontWait', 'DONTWAIT')
        ]
    }
}%

${LICENSE}

public struct Socket: FileDescriptor
{
    public var fileDescriptor: Int32

    @available(*, renamed: "init")
    public init(domain: SocketDomains, type: SocketTypes, protocol ptcl: Int32)
    {
        fileDescriptor = socket(Int32(domain.rawValue), type.rawValue, ptcl)
    }

    public init(family: SocketDomains, type: SocketTypes, protocol ptcl: Int32)
    {
        fileDescriptor = socket(Int32(family.rawValue), type.rawValue, ptcl)
    }

    public init(raw: Int32)
    {
        assert(raw > 0)
        self.fileDescriptor = raw
    }

    public static func makePair(domain: SocketDomains,
                                type: SocketTypes,
                                `protocol`: Int32) throws -> (Socket, Socket)
    {
        var pair: (Int32, Int32) = (0, 0)
        _ = try sguard("socketpair") {
            socketpair(Int32(domain.rawValue),
                       type.rawValue,
                       `protocol`,
                       mutablePointer(of: &pair).cast(to: Int32.self))
        }

        return (Socket(raw: pair.0), Socket(raw: pair.1))
    }

    public var blocking: Bool
    {
        get {
            return !flags.contains(.nonblock)
        } set {
            if newValue {
                flags.remove(.nonblock)
            } else {
                flags.insert(.nonblock)
            }
        }
    }
}

extension Socket
{
    public func bind(_ addr: SocketAddress) throws
    {
        _ = try sguard("bind") {
            addr.withSockAddrPointer {
                xlibc.bind(fileDescriptor, $0, addr.socklen)
            }
        }
    }

    public func bind(_ addr: SocketAddress, port: in_port_t)
    {
        switch addr.type {
        case .inet:
            guard var inet = addr.inet() else {
                return
            }
            getpagesize()
            inet.sin_port = port.byteSwapped
            _ = xlibc.bind(fileDescriptor,
                           pointer(of: &inet).cast(to: sockaddr.self),
                           addr.socklen)
        case .inet6:
            guard var inet6 = addr.inet6() else {
                return
            }
            inet6.sin6_port = port.byteSwapped
            _ = xlibc.bind(fileDescriptor,
                           pointer(of: &inet6).cast(to: sockaddr.self),
                           addr.socklen)
        default:
            break
        }
    }

    public func accept() throws -> (Socket, SocketAddress)
    {
        var addr = _sockaddr_storage()
        var socklen: socklen_t = 0

        let fd = try sguard("accept") {
            xlibc.accept(self.fileDescriptor,
                         mutablePointer(of: &addr).cast(to: sockaddr.self),
                         &socklen)
        }

        return (Socket(raw: fd), SocketAddress(storage: addr))
    }

    public func connect(to addr: SocketAddress) throws
    {
        _ = try sguard("connect") {
            addr.withSockAddrPointer {
                xlibc.connect(fileDescriptor, $0, addr.socklen)
            }
        }
    }

    public func listen(_ backlog: Int32 = Int32(Int32.max)) throws
    {
        _ = try sguard("listen") {
            xlibc.listen(fileDescriptor, backlog)
        }
    }

    @discardableResult
    public func send(bytes: AnyPointer,
                     length: Int, flags: SendFlags) throws -> Int
    {
        return try sguard("send") {
            xlibc.send(fileDescriptor, bytes.rawPointer, length, flags.rawValue)
        }
    }

    @discardableResult
    public func recv(to buffer: AnyMutablePointer,
                     length: Int, flags: RecvFlags) throws -> Int
    {
        return try sguard("recv") {
            xlibc.recv(fileDescriptor,
                       buffer.mutableRawPointer,
                       length, flags.rawValue)
        }
    }

    @discardableResult
    public func send(to dest: SocketAddress,
                     bytes: AnyPointer,
                     length: Int, flags: SendFlags) throws -> Int
    {
        return try sguard("sendto") {
            dest.withSockAddrPointer {
                sendto(fileDescriptor, bytes.rawPointer, length,
                       flags.rawValue, $0, dest.socklen)
            }
        }
    }

    @discardableResult
    public func received(to buffer: AnyMutablePointer,
                         length: Int,
                         flags: RecvFlags)
        throws -> (sender: SocketAddress, size: Int)
    {
        var storage = _sockaddr_storage()
        let i = try sguard("recvfrom") {
            recvfrom(fileDescriptor,
                     buffer.mutableRawPointer, length, flags.rawValue,
                     mutablePointer(of: &storage).cast(to: sockaddr.self), nil)
        }
        return (sender: SocketAddress(storage: storage), size: i)
    }
}

%for verb in ['Send', 'Recv']:
public struct ${verb}Flags: OptionSet
{
${OptionSetBody('public', 'Int32')}
    %for (name, key) in flags[verb]:
    public static let ${name} = ${verb}Flags(rawValue: Int32(MSG_${key}))
    %end
    %if verb == 'Send':
    #if !os(Linux)
    /// data completes transcation
    public static let eof = SendFlags(rawValue: MSG_EOF)
    #endif

    #if os(Linux) || os(FreeBSD)
    /// do not generate sigpipe
    public static let noSignal = SendFlags(rawValue: Int32(MSG_NOSIGNAL))
    #endif
    %else:
    #if os(FreeBSD)
    /// Do not block after receiving the first message (only for `recvmmsg()`)
    public static let waitForOne = RecvFlags(rawValue: MSG_WAITFORONE)
    #endif
    %end
}
%end

extension Socket
{
    func setsock<ArgType>(opt: SocketOptions, value: ArgType)
    {
        var _val = value
        setsockopt(fileDescriptor,
                   opt.layer,
                   opt.rawValue,
                   pointer(of: &_val).rawPointer,
                   socklen_t(MemoryLayout<ArgType>.size))
    }

    func getsock<ArgType>(opt: SocketOptions) -> ArgType
    {
        var ret: ArgType!
        var size = socklen_t(MemoryLayout<ArgType>.size)
        getsockopt(fileDescriptor,
                   opt.layer,
                   opt.rawValue,
                   mutablePointer(of: &ret).mutableRawPointer,
                   &size)
        return ret
    }
%{
def make_getter_setters(os):
    ret = '\n'
    if os == '':
        source = uni_sockopts
    elif os == 'fbsd':
        source = fbsd_opts
        ret = '#if ' + fbsd
    elif os == 'linux':
        source = linux_opts
        ret = '#if os(Linux)'
    elif os == 'BSD':
        source = bsd_opts
        ret = '#if ' + BSD

    for (name, key, type) in source:
        ret = ret + '\n' +\
        '    public var ' + name + ': ' + type + '\n' +\
        '    {\n' +\
        '        get {\n' +\
        '            return getsock(opt: .' + name +')\n' +\
        '        } '
        if name not in immutable:
            ret = ret + 'nonmutating set {\n' +\
        '            setsock(opt: .' + name + ', value: newValue)\n' +\
        '        }\n'
        else:
            ret = ret + '\n'
        ret = ret + '    }\n'

    if os != '':
        ret = ret + '    #endif\n'
    return ret
}%

    ${make_getter_setters('')}
    ${make_getter_setters('fbsd')}
    ${make_getter_setters('linux')}
    ${make_getter_setters('BSD')}

    #if os(Linux)
    public var bindedDevice: String
    {
        get {
            let cstr: UnsafePointer<CChar> = getsock(opt: .bindedDevice)
            return String(cString: cstr)
        } set {
            let fd = self.fileDescriptor
            newValue.withCString {
               setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, $0, 
                          socklen_t(newValue.characters.count))
            }
        }
    }
    #endif
}

public struct SocketOptions: RawRepresentable
{
    public typealias RawValue = Int32
    public var rawValue: Int32
    public var layer: Int32

    public init(rawValue: Int32)
    {
        self.rawValue = rawValue
        self.layer = SOL_SOCKET
    }

    public init(_ layer: Int32, _ rawValue: Int32)
    {
        self.layer = layer
        self.rawValue = rawValue
    }

    public init(_ layer: Int, _ rawValue: Int32)
    {
        self.layer = Int32(layer)
        self.rawValue = rawValue
    }

    public init(_ layer: UInt32, _ rawValue: Int32)
    {
        self.layer = Int32(layer)
        self.rawValue = rawValue
    }

    #if os(Linux)
    public static let bindedDevice = SocketOptions(SOL_SOCKET, SO_BINDTODEVICE)
    #endif

    %for (os, ops) in [('os(Linux)', linux_opts), (fbsd, fbsd_opts),\
    %                (BSD, bsd_opts), ('', uni_sockopts)]:
    %if os != '':
    #if ${os}
    %end
    %for (name, key, type) in ops:
    public static let ${name} = SocketOptions(SOL_SOCKET, SO_${key.upper()})
    %end
    %if os != '':
    #endif
    %end
    %end

}
