%{
    from Common import *
}%

${LICENSE}

public struct NetworkInterface: CustomStringConvertible
{
    public fileprivate(set) var name: String
    public fileprivate(set) var address: SocketAddress?
    public fileprivate(set) var netmask: SocketAddress?

    var _dest: SocketAddress?
    var flags: UInt32
    
    public var family: SocketFamilies
    {
        return address!.family
    }

    public var destaddr: SocketAddress?
    {
        return _dest
    }
    
    public var bcastaddr: SocketAddress?
    {
        return _dest
    }

    public init(raw: UnsafePointer<ifaddrs>)
    {
        name = String(cString: raw.pointee.ifa_name)
        address = SocketAddress(addr: raw.pointee.ifa_addr)
    
        #if os(Linux)
            let dst = raw.pointee.ifa_ifu.ifu_dstaddr
        #else
            let dst = raw.pointee.ifa_dstaddr
        #endif
    
        if (dst != nil) {
            _dest = SocketAddress(addr: dst!)
        }
        if (raw.pointee.ifa_netmask != nil) {
            netmask = SocketAddress(addr: raw.pointee.ifa_netmask)
        }
        flags = raw.pointee.ifa_flags
        
    }

    public var description: String
    {
        return "\(name) \(address?.description ?? "")"
    }

    @inline(__always)
    private func contains(_ f: Int32) -> Bool
    {
        return (flags & UInt32(f)) == UInt32(f)
    }

    @inline(__always)
    private func contains(_ f: Int) -> Bool
    {
        return (flags & UInt32(f)) == UInt32(f)
    }

    @available(*, deprecated, message: "use supportBroadcast instead")
    public var isVaildBroadcast: Bool
    {
        return contains(IFF_BROADCAST) && self.address!.family == .inet
    }
    
    public var supportBroadcast: Bool
    {
        return contains(IFF_BROADCAST) && self.address!.family == .inet
    }

%{
    opts = [('up', 'up'), ('debug', 'debug'), ('isLoopback', 'loopback'),
            ('noArp', 'noarp'), ('promiscousMode', 'promisc'),
            ('avoidTrailers', 'notrailers'), ('recvAllMulticast', 'allmulti'),
            ('supportMulticast', 'multicast'), ('running', 'running')]
}%

%for (name, key) in opts:
    public var ${name}: Bool
    {
        return contains(IFF_${key.upper()})
    }

%end

    #if !os(Linux)
    public var simplex: Bool
    {
        return contains(IFF_SIMPLEX)
    }
    #endif

    public static var interfaces: [NetworkInterface]
    {
        var head: UnsafeMutablePointer<ifaddrs>?
        var cur: UnsafeMutablePointer<ifaddrs>?

        var intefaces = [NetworkInterface]()

        getifaddrs(&head)

        cur = head;

        while (cur != nil) {
            intefaces.append(NetworkInterface(raw: cur!))
            cur = cur!.pointee.ifa_next
        }

        freeifaddrs(head)
        return intefaces
    }

    public static func interfaces(support domains: Set<SocketDomains>)
        -> [NetworkInterface]
    {
        var head: UnsafeMutablePointer<ifaddrs>?
        var cur: UnsafeMutablePointer<ifaddrs>?
        var intefaces = [NetworkInterface]()

        getifaddrs(&head)

        cur = head;

        while (cur != nil) {
            if let domain = SocketDomains(rawValue: cur!.pointee.ifa_addr.pointee.sa_family) {
                if domains.contains(domain) {
                    intefaces.append(NetworkInterface(raw: cur!));
                }
            }
            cur = cur!.pointee.ifa_next
        }

        freeifaddrs(head)
        return intefaces
    }

    public static func interface(named: String,
                                 support domain: SocketDomains)
        -> NetworkInterface?
    {
        var head: UnsafeMutablePointer<ifaddrs>?
        var cur: UnsafeMutablePointer<ifaddrs>?

        var inteface: NetworkInterface?

        getifaddrs(&head)

        cur = head;

        while (cur != nil)
        {
            if let _domain = SocketDomains(rawValue:
                cur!.pointee.ifa_addr.pointee.sa_family) {
                if (_domain == domain) {
                    inteface = NetworkInterface(raw: cur!)
                }
            }
            cur = cur!.pointee.ifa_next
        }

        freeifaddrs(head)
        return inteface
    }

    public static func interfaces(named: String) -> [NetworkInterface]
    {
        var head: UnsafeMutablePointer<ifaddrs>?
        var cur: UnsafeMutablePointer<ifaddrs>?
        var intefaces = [NetworkInterface]()

        getifaddrs(&head)

        cur = head;

        while (cur != nil) {
            let name = String(cString: cur!.pointee.ifa_name)
            if name == named {
                intefaces.append(NetworkInterface(raw: cur!));
            }
            cur = cur!.pointee.ifa_next
        }

        freeifaddrs(head)
        return intefaces
    }
}
