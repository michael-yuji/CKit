%{
    from Common import *
    from Helper import *
    from collections import *

    kos = {
        'bsd' : (fbsd, [
             ('read', -1), ('write', -2), ('aio', -3), ('vnode', -4),
             ('process', -5), ('signal', -6), ('timer', -7), ('user', -11)
        ]),
        'darwin' : (Darwin, [
             ('read', -1), ('write', -2), ('aio', -3),\
             ('vnode', -4), ('process', -5), ('signal', -6),\
             ('timer', -7), ('user', -10), ('macport', -8),\
             ('vm', -12), ('except', -15)
        ])
    }

    supportedEvents = [
        'read', 'write', 'vnode', 'process', 'signal', 'timer', 'user'
    ]

    fullname = {
        'read' : 'read',
        'write' : 'write',
        'aio' : 'asyncIO',
        'vnode' : 'file',
        'process' : 'process',
        'signal' : 'signal',
        'timer' : 'timer',
        'user' : 'user',
        'vm' : 'vitrualMemory'
    }

    opts = {
        'read' : [],
        'write' : [],
        'vnode' : [
            ('attributesChanged', 'NOTE_ATTRIB'),
            ('delete', 'NOTE_DELETE'),
            ('extend', 'NOTE_EXTEND'),
            ('link', 'NOTE_LINK'),
            ('rename', 'NOTE_RENAME'),
            ('revoke', 'NOTE_REVOKE'),
            ('write', 'NOTE_WRITE')
        ],
        'process' : [
            ('exit', 'NOTE_EXIT'),
            ('fork', 'NOTE_FORK'),
            ('exec', 'NOTE_EXEC'),
            ('track', 'NOTE_TRACK')
        ],
        'signal' : [],
        'timer' : [
            ('seconds', 'NOTE_SECONDS'),
            ('macroseconds', 'NOTE_USECONDS'),
            ('nanoseconds', 'NOTE_NSECONDS'),
        ],
        'user' : [
            ('none', 'NOTE_FFNOP'),
            ('ignore', 'NOTE_FFNOP'),
            ('trigger', 'NOTE_TRIGGER'),
            ('copy', 'NOTE_FFNOP')
        ]
    }
}%

${LICENSE}

%for (os) in ['bsd', 'darwin']:
#if ${kos[os][0]}
public enum KernelEventType: Int16
{
    %for (type, code) in kos[os][1]:
    case ${type} = ${code}
    %end

    public typealias RawValue = Int16
    public var rawValue: Int16
    {
        switch self {
        %for (type, code) in kos[os][1]:
        case .${type}:
            return ${code}
        %end
        }
    }

    public init(rawValue: Int16)
    {
        self =
        %for (type, code) in kos[os][1]:
            rawValue == ${code} ? .${type} :
        %end
            .user
    }
}
#endif

%end

#if ${BSD}

public typealias KernelEvent = kevent

public protocol KernelEventFlags
{
    var rawValue: UInt32 { get }
}

/// A bit compatible type of kevent, with some more understandble name
public struct KernelEventResult
{
    /// identifier
    public var ident: UInt

    /// type of filter
    public var type: Int16

    /// action (EV_ADD, EV_ENABLE, ... )
    public var action: UInt16

    /// filter specified flags
    public var flag: UInt32

    /// data
    public var data: Int

    /// User defined data
    public var udata: UnsafeMutableRawPointer!
}

/// basically kevent without action
public struct KernelEventDescriptor {
    public var identifier: UInt
    public var type: KernelEventType
    public var flags: KernelEventFlags
    public var userData: KernelEventUserData?
}

// -MARK: Initialization
extension KernelEventDescriptor
{
    public init(event: KernelEvent)
    {
        self.identifier = event.ident
        self.type = KernelEventType(rawValue: event.filter)
        self.userData = .pointer(event.udata)

        switch self.type {
        case KernelEventType.vnode:
            self.flags = KernelEventVnodeFlags(rawValue: event.fflags)
        case KernelEventType.timer:
            self.flags = KernelEventTimerFlags(rawValue: event.fflags)
        case KernelEventType.process:
            self.flags = KernelEventProcessFlags(rawValue: event.fflags)
        default:
            self.flags = KernelEventFlagsNone()
        }
    }

    public init(ident: UInt,
                type: KernelEventType,
                flags: KernelEventFlags,
                userData: KernelEventUserData? = nil)
    {
        self.identifier = ident
        self.type = type
        self.flags = flags
        self.userData = userData
    }
}

extension KernelEventDescriptor
{
    public static func read(ident: Int32,
                            userData: KernelEventUserData? = nil
        ) -> KernelEventDescriptor
    {
        return KernelEventDescriptor(ident: UInt(ident),
                                     type: .read,
                                     flags: KernelEventFlagsNone(),
                                     userData: userData)
    }

    public static func write(ident: Int32,
                             userData: KernelEventUserData? = nil
        ) -> KernelEventDescriptor
    {
        return KernelEventDescriptor(ident: UInt(ident),
                                     type: .write,
                                     flags: KernelEventFlagsNone(),
                                     userData: userData)
    }

    public static func file(fd: Int32,
                            for evs: KernelEventFlags.Vnode,
                            userData: KernelEventUserData? = nil
        ) -> KernelEventDescriptor
    {
        return KernelEventDescriptor(ident: UInt(fd),
                                     type: .vnode,
                                     flags: evs,
                                     userData: userData)
    }

    public static func timer(ident: UInt,
                             unit: KernelEventFlags.Timer,
                             userData: KernelEventUserData? = nil
        ) -> KernelEventDescriptor
    {
        return KernelEventDescriptor(ident: ident,
                                     type: .timer,
                                     flags: unit,
                                     userData: userData)
    }

    public static func process(pid: pid_t,
                               for evs: KernelEventFlags.Process,
                               userData: KernelEventUserData? = nil
        ) -> KernelEventDescriptor
    {
        return KernelEventDescriptor(ident: UInt(pid),
                                     type: .process,
                                     flags: evs,
                                     userData: userData)
    }

    public static func signal(sig: Int32,
                              userData: KernelEventUserData? = nil
        ) -> KernelEventDescriptor
    {
        return KernelEventDescriptor(ident: UInt(sig),
                                     type: .signal,
                                     flags: KernelEventFlagsNone(),
                                     userData: userData)
    }

    public static func user(ident: UInt,
                            options: KernelEventFlags.User,
                            userData: KernelEventUserData? = nil
        ) -> KernelEventDescriptor
    {
        return KernelEventDescriptor(ident: ident,
                                     type: .user,
                                     flags: options,
                                     userData: userData)
    }

    public func makeEvent(_ action: KernelEventAction) -> KernelEvent
    {
        return KernelEvent(ident: identifier,
                           filter: type.rawValue,
                           flags: action.rawValue,
                           fflags: flags.rawValue,
                           data: 0,
                           udata: userData == nil ? nil : userData!.rawValue)
    }
}

extension KernelEventDescriptor: Equatable
{
    public static func ==(lhs: KernelEventDescriptor,
                          rhs: KernelEventDescriptor) -> Bool
    {
        return lhs.identifier == rhs.identifier && lhs.type == rhs.type
    }
}

public extension xlibc.kevent
{
    public static func readEvent(_ ident: Int32,
                                 action: KernelEventAction,
                                 udata: UnsafeMutableRawPointer? = nil
        ) -> kevent
    {
        return KernelEvent(ident: UInt(ident),
                    filter: KernelEventType.read.rawValue,
                    flags: action.rawValue,
                    fflags: 0, data: 0,
                    udata: udata)
    }

    public static func writeEvent(_ ident: Int32,
                                  action: KernelEventAction,
                                  udata: UnsafeMutableRawPointer? = nil
        ) -> kevent
    {
        return KernelEvent(ident: UInt(ident),
                    filter: KernelEventType.write.rawValue,
                    flags: action.rawValue,
                    fflags: 0, data: 0,
                    udata: udata)
    }

    public static func fileEvent(_ ident: Int32,
                                 action: KernelEventAction,
                                 filter: KernelEventFlags.Vnode,
                                 udata: UnsafeMutableRawPointer? = nil
        ) -> kevent
    {
        return KernelEvent(ident: UInt(ident),
                    filter: KernelEventType.write.rawValue,
                    flags: action.rawValue,
                    fflags: filter.rawValue,
                    data: 0, udata: udata)
    }

    public static func processEvent(_ pid: pid_t,
                                    action: KernelEventAction,
                                    filter: KernelEventFlags.Process,
                                    udata: UnsafeMutableRawPointer? = nil
        ) -> kevent
    {
        return KernelEvent(ident: UInt(pid),
                    filter: KernelEventType.process.rawValue,
                    flags: action.rawValue,
                    fflags: filter.rawValue, data: 0,
                    udata: udata)
    }

    public static func signalEvent(_ signal: Int32,
                                   action: KernelEventAction,
                                   udata: UnsafeMutableRawPointer? = nil
        ) -> kevent
    {
        return KernelEvent(ident: UInt(signal),
                    filter: KernelEventType.signal.rawValue,
                    flags: action.rawValue,
                    fflags: 0, data: 0,
                    udata: udata)
    }

    public static func timerEvent(id: UInt,
                                  action: KernelEventAction,
                                  timeout: Int,
                                  unit: KernelEventFlags.Timer,
                                  udata: UnsafeMutableRawPointer? = nil
        ) -> kevent
    {
        return KernelEvent(ident: id,
                    filter: KernelEventType.timer.rawValue,
                    flags: action.rawValue,
                    fflags: unit.rawValue,
                    data: timeout, udata: udata)
    }
}

%for arch in ['arch(arm) || arch(i386)', 'arch(x86_64) || arch(arm64)']:
#if ${arch}
public enum KernelEventUserData
{
    %for case in ['', '64', '32', '16', '8']:
    %for u in ['', 'U']:
    %if case == '32' and arch == 'arch(arm) || arch(i386)':
    %   pass
    %else:
    case ${u.lower() + 'int' + case}(${u}Int${case})
    %end
    %end
    %end

    case pointer(UnsafeMutableRawPointer)
    var rawValue: UnsafeMutableRawPointer!
    {
        switch self {
    %for case in ['', '64', '32', '16', '8']:
    %for u in ['', 'U']:
    %if case != '32' or arch != 'arch(arm) || arch(i386)':
        case let .${ u.lower() + 'int' + case}(i):
            return UInt(i) == 0 ?
                nil : UnsafeMutableRawPointer(bitPattern: UInt(i))
    %end
    %end
    %end
        case let .pointer(p):
            return p
        }
    }
}
#endif

%end

public struct KernelEventAction: OptionSet
{
${OptionSetBody('public', 'UInt16')}
%{
    actions = ['add', 'delete', 'enable', 'disable', 'dispatch', \
    'receipt', 'oneshot', 'clear', 'error', 'eof']
}%
    %for action in actions:
    public static let ${action}
        = KernelEventAction(rawValue: UInt16(EV_${action.upper()}))
    %end
}

%for event in supportedEvents:
public struct KernelEvent${capitalize(event)}Flags: KernelEventFlags, RawRepresentable
{
${OptionSetBody('public', 'UInt32')}
%for (name, key) in opts[event]:
    public static let ${name}
        = KernelEvent${capitalize(event)}Flags(rawValue: UInt32(${key}))
%end
}

%end
public struct KernelEventFlagsNone: KernelEventFlags, RawRepresentable
{
    public typealias RawValue = UInt32
    public var rawValue: UInt32
    {
        return 0
    }

    public init(rawValue: UInt32) {}
    public init() {}
}

public extension KernelEventFlags
{
%for event in supportedEvents:
    public typealias ${capitalize(event)} = KernelEvent${capitalize(event)}Flags
%end
    public typealias None = KernelEventFlagsNone
}

#endif
